<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>slist_generic: list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">slist_generic
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('list_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">list.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>File containing the data structure and the declaration of the function that permit to handle single linked list.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
</div>
<p><a href="list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnode.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic node element.  <a href="structnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1a6b6fb557d8d37d59700faf4e4c9167"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a1a6b6fb557d8d37d59700faf4e4c9167">mode</a> { <a class="el" href="list_8h.html#a1a6b6fb557d8d37d59700faf4e4c9167a6ec9ae46a1e5c631ae04fc9c4c2d63bc">ASC</a>, 
<a class="el" href="list_8h.html#a1a6b6fb557d8d37d59700faf4e4c9167ac09f77dd64a2d5dedf24b5835d9eaa5a">DESC</a>
 }</td></tr>
<tr class="memdesc:a1a6b6fb557d8d37d59700faf4e4c9167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of sorting list.  <a href="list_8h.html#a1a6b6fb557d8d37d59700faf4e4c9167">More...</a><br /></td></tr>
<tr class="separator:a1a6b6fb557d8d37d59700faf4e4c9167"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2dc0e71ae2f5906587e39099467814bf"><td class="memItemLeft" align="right" valign="top"><a id="a2dc0e71ae2f5906587e39099467814bf"></a>
struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>insert_all</b> (struct <a class="el" href="structnode.html">node</a> *list, size_t data_size, size_t <a class="el" href="list_8h.html#a56990ae5784516ec0481320f457bed7c">count</a>,...)</td></tr>
<tr class="separator:a2dc0e71ae2f5906587e39099467814bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c80ee5000d4aa103d472eb00c20fd5b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a2c80ee5000d4aa103d472eb00c20fd5b">insert_head</a> (struct <a class="el" href="structnode.html">node</a> *list, const void *data, size_t data_size)</td></tr>
<tr class="memdesc:a2c80ee5000d4aa103d472eb00c20fd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node at the head.  <a href="list_8h.html#a2c80ee5000d4aa103d472eb00c20fd5b">More...</a><br /></td></tr>
<tr class="separator:a2c80ee5000d4aa103d472eb00c20fd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d65019833e12b4f6d8f94f09cf6883"><td class="memItemLeft" align="right" valign="top"><a id="af5d65019833e12b4f6d8f94f09cf6883"></a>
struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>insert_tail</b> (struct <a class="el" href="structnode.html">node</a> *list, const void *data)</td></tr>
<tr class="separator:af5d65019833e12b4f6d8f94f09cf6883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9c631824242db0d7c812dc1ec8f901"><td class="memItemLeft" align="right" valign="top"><a id="aaa9c631824242db0d7c812dc1ec8f901"></a>
struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>insert_at</b> (int index, struct <a class="el" href="structnode.html">node</a> *list, const void *data, size_t data_size)</td></tr>
<tr class="separator:aaa9c631824242db0d7c812dc1ec8f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4876284586ad1cd4e90f5aba320c7081"><td class="memItemLeft" align="right" valign="top"><a id="a4876284586ad1cd4e90f5aba320c7081"></a>
struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>insert_from_bin_file</b> (char *filename)</td></tr>
<tr class="separator:a4876284586ad1cd4e90f5aba320c7081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec05bdd79ecc46792a393fb96cd59af"><td class="memItemLeft" align="right" valign="top"><a id="a0ec05bdd79ecc46792a393fb96cd59af"></a>
struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>update_at</b> (int index, struct <a class="el" href="structnode.html">node</a> *list, const void *data, size_t data_size)</td></tr>
<tr class="separator:a0ec05bdd79ecc46792a393fb96cd59af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0753f97eecddba06756217e51ccc88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a0a0753f97eecddba06756217e51ccc88">delete</a> (struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="memdesc:a0a0753f97eecddba06756217e51ccc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete all list elements  <a href="list_8h.html#a0a0753f97eecddba06756217e51ccc88">More...</a><br /></td></tr>
<tr class="separator:a0a0753f97eecddba06756217e51ccc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27ce1773699876a27d5de71a462a144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ae27ce1773699876a27d5de71a462a144">delete_head</a> (struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="memdesc:ae27ce1773699876a27d5de71a462a144"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete head  <a href="list_8h.html#ae27ce1773699876a27d5de71a462a144">More...</a><br /></td></tr>
<tr class="separator:ae27ce1773699876a27d5de71a462a144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17a0b410d79332d352094d93f25654c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#af17a0b410d79332d352094d93f25654c">delete_tail</a> (struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="memdesc:af17a0b410d79332d352094d93f25654c"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete tail  <a href="list_8h.html#af17a0b410d79332d352094d93f25654c">More...</a><br /></td></tr>
<tr class="separator:af17a0b410d79332d352094d93f25654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274bdd3e14a1f7a2e29810d97e36eea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a274bdd3e14a1f7a2e29810d97e36eea0">delete_at</a> (int index, struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="memdesc:a274bdd3e14a1f7a2e29810d97e36eea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete at the position  <a href="list_8h.html#a274bdd3e14a1f7a2e29810d97e36eea0">More...</a><br /></td></tr>
<tr class="separator:a274bdd3e14a1f7a2e29810d97e36eea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c418dd33a233908610afd0285a8c8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a35c418dd33a233908610afd0285a8c8b">is_empty</a> (const struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="memdesc:a35c418dd33a233908610afd0285a8c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">list empty  <a href="list_8h.html#a35c418dd33a233908610afd0285a8c8b">More...</a><br /></td></tr>
<tr class="separator:a35c418dd33a233908610afd0285a8c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56990ae5784516ec0481320f457bed7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a56990ae5784516ec0481320f457bed7c">count</a> (const struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="memdesc:a56990ae5784516ec0481320f457bed7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">count item's list  <a href="list_8h.html#a56990ae5784516ec0481320f457bed7c">More...</a><br /></td></tr>
<tr class="separator:a56990ae5784516ec0481320f457bed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d462bdd6a6dc9b0bc6e0cde5ef0fdd"><td class="memItemLeft" align="right" valign="top"><a id="a85d462bdd6a6dc9b0bc6e0cde5ef0fdd"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>get_head_data</b> (const struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="separator:a85d462bdd6a6dc9b0bc6e0cde5ef0fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed3bdbd1ab9485f1bc0e2e3c10e1bbb"><td class="memItemLeft" align="right" valign="top"><a id="a7ed3bdbd1ab9485f1bc0e2e3c10e1bbb"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>get_tail_data</b> (const struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="separator:a7ed3bdbd1ab9485f1bc0e2e3c10e1bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e7080ef2dfbd975d44c159d514e0ba"><td class="memItemLeft" align="right" valign="top"><a id="a00e7080ef2dfbd975d44c159d514e0ba"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>get_data_at</b> (int index, const struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="separator:a00e7080ef2dfbd975d44c159d514e0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec949137853999cc1d9c5d79100d2b8e"><td class="memItemLeft" align="right" valign="top"><a id="aec949137853999cc1d9c5d79100d2b8e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_of</b> (const void *data, const struct <a class="el" href="structnode.html">node</a> *list, int(*compare)(const void *a, const void *b))</td></tr>
<tr class="separator:aec949137853999cc1d9c5d79100d2b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a311500e900ab98129f21a8711253d8"><td class="memItemLeft" align="right" valign="top"><a id="a4a311500e900ab98129f21a8711253d8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_index_of</b> (const void *data, const struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="separator:a4a311500e900ab98129f21a8711253d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af520f1a7da3f6924e3c91784389d38fe"><td class="memItemLeft" align="right" valign="top"><a id="af520f1a7da3f6924e3c91784389d38fe"></a>
struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (int index, const struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="separator:af520f1a7da3f6924e3c91784389d38fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7062886fa702f8865ff5a70994876f5"><td class="memItemLeft" align="right" valign="top"><a id="ae7062886fa702f8865ff5a70994876f5"></a>
struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>filter</b> (const struct <a class="el" href="structnode.html">node</a> *list, size_t data_size, bool(*compare)(const void *<a class="el" href="structnode.html">node</a>))</td></tr>
<tr class="separator:ae7062886fa702f8865ff5a70994876f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fc79918630666ebbfdb755bee11012"><td class="memItemLeft" align="right" valign="top"><a id="a79fc79918630666ebbfdb755bee11012"></a>
struct <a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>reverse</b> (const struct <a class="el" href="structnode.html">node</a> *list)</td></tr>
<tr class="separator:a79fc79918630666ebbfdb755bee11012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8829e83ebaa8ca3234da15f0cae6211"><td class="memItemLeft" align="right" valign="top"><a id="aa8829e83ebaa8ca3234da15f0cae6211"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> (struct <a class="el" href="structnode.html">node</a> **list, int(*cmp)(void *a, void *b), void(*swap)(void *a, void *b), int MODE)</td></tr>
<tr class="separator:aa8829e83ebaa8ca3234da15f0cae6211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fb0960f3c79b071bd205359eb4fa4a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a16fb0960f3c79b071bd205359eb4fa4a">min_list</a> (const struct <a class="el" href="structnode.html">node</a> *list, int(*compare)(void *a, void *b))</td></tr>
<tr class="memdesc:a16fb0960f3c79b071bd205359eb4fa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the min of the list.  <a href="list_8h.html#a16fb0960f3c79b071bd205359eb4fa4a">More...</a><br /></td></tr>
<tr class="separator:a16fb0960f3c79b071bd205359eb4fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951ef51ed47fe41133ba1b2e357bab17"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a951ef51ed47fe41133ba1b2e357bab17">max_list</a> (const struct <a class="el" href="structnode.html">node</a> *list, int(*compare)(void *a, void *b))</td></tr>
<tr class="memdesc:a951ef51ed47fe41133ba1b2e357bab17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the max of the list.  <a href="list_8h.html#a951ef51ed47fe41133ba1b2e357bab17">More...</a><br /></td></tr>
<tr class="separator:a951ef51ed47fe41133ba1b2e357bab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>File containing the data structure and the declaration of the function that permit to handle single linked list. </p>
<dl class="section author"><dt>Author</dt><dd>Omar Mohseni </dd></dl>
<dl class="section date"><dt>Date</dt><dd>14 Jun 2020 </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1a6b6fb557d8d37d59700faf4e4c9167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6b6fb557d8d37d59700faf4e4c9167">&#9670;&nbsp;</a></span>mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="list_8h.html#a1a6b6fb557d8d37d59700faf4e4c9167">mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method of sorting list. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1a6b6fb557d8d37d59700faf4e4c9167a6ec9ae46a1e5c631ae04fc9c4c2d63bc"></a>ASC&#160;</td><td class="fielddoc"><p>ascending </p>
</td></tr>
<tr><td class="fieldname"><a id="a1a6b6fb557d8d37d59700faf4e4c9167ac09f77dd64a2d5dedf24b5835d9eaa5a"></a>DESC&#160;</td><td class="fielddoc"><p>descending </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a56990ae5784516ec0481320f457bed7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56990ae5784516ec0481320f457bed7c">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>count item's list </p>
<p>This function count how many elements are in the list <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code></code>(const <code>struct</code> <code>node*</code>) Const pointer to a struct node that rappresent the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>zero</code> if the list is empty</li>
<li><code>major</code> <code>then</code> <code>zero</code> if the list isn't empty </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0a0753f97eecddba06756217e51ccc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0753f97eecddba06756217e51ccc88">&#9670;&nbsp;</a></span>delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delete all list elements </p>
<p>This function deletes all list elements <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code></code>(struct <code>node*</code>) Pointer to a struct node that rappresent the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a274bdd3e14a1f7a2e29810d97e36eea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274bdd3e14a1f7a2e29810d97e36eea0">&#9670;&nbsp;</a></span>delete_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delete at the position </p>
<p>This function deletes the node that it's at</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position <br  />
 </td></tr>
    <tr><td class="paramname">list</td><td><code></code>(struct <code>node*</code>) Pointer to a struct node that rappresent the list </td></tr>
    <tr><td class="paramname">index</td><td><code></code>(int) Indicate the position of the element that have to be deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae27ce1773699876a27d5de71a462a144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27ce1773699876a27d5de71a462a144">&#9670;&nbsp;</a></span>delete_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delete head </p>
<p>This function deletes the head of the list <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code></code>(struct <code>node*</code>) Pointer to a struct node that rappresent the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af17a0b410d79332d352094d93f25654c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17a0b410d79332d352094d93f25654c">&#9670;&nbsp;</a></span>delete_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delete tail </p>
<p>This function deletes the tail of the list <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code></code>(struct <code>node*</code>) Pointer to a struct node that rappresent the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c80ee5000d4aa103d472eb00c20fd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c80ee5000d4aa103d472eb00c20fd5b">&#9670;&nbsp;</a></span>insert_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnode.html">node</a>* insert_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new node at the head. </p>
<p>This function allocate a new node in the heap memory. Then it fills the info field with the data passed to the function At the end it links the new node to the previous list and returns the list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code></code>(struct <code>node*</code>) Pointer to a struct node that rappresent the list </td></tr>
    <tr><td class="paramname">data</td><td><code></code>(void*) Pointer to a void that point to an area of heap memory that contains the data to insert </td></tr>
    <tr><td class="paramname">data_size</td><td><code></code>(size_t) size of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code></code>(struct <code>node*</code>) Pointer to the head of the list </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When you use C strings add the terminator in the count of the data_size <div class="fragment"><div class="line"><span class="keywordtype">char</span> name[] = <span class="stringliteral">&quot;Luca&quot;</span>;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structnode.html">node</a> *list = <a class="code" href="list_8h.html#a2c80ee5000d4aa103d472eb00c20fd5b">insert_head</a>(list, name, 1 + strlen(name));</div>
</div><!-- fragment --> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Always return the result of the function to the list pointer because you lose the reference to that area of memory. </dd></dl>

</div>
</div>
<a id="a35c418dd33a233908610afd0285a8c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c418dd33a233908610afd0285a8c8b">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>list empty </p>
<p>This function tests if the list is empty <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code></code>(struct <code>node*</code>) Pointer to a struct node that rappresent the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if the list is empty</li>
<li><code>false</code> if the list isn't empty </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a951ef51ed47fe41133ba1b2e357bab17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951ef51ed47fe41133ba1b2e357bab17">&#9670;&nbsp;</a></span>max_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* max_list </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *a, void *b)&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the max of the list. </p>
<p>This function returns the max of the list.The user pass a function pointer to the function that rappresent the criteria that two memory object are compared. <code>Example</code> Let's define this structure </p><div class="fragment"><div class="line"><span class="keyword">struct </span>persona { <span class="keywordtype">char</span> name[20], <span class="keywordtype">int</span> age};</div>
</div><!-- fragment --><p> Then fill the list of struct persona </p><div class="fragment"><div class="line"><span class="keyword">struct </span>persona p1 = { <span class="stringliteral">&quot;omar&quot;</span>, 19 };</div>
<div class="line"><span class="keyword">struct </span>persona p2 = { <span class="stringliteral">&quot;valerio&quot;</span>, 29};</div>
<div class="line"> </div>
<div class="line">list = <a class="code" href="list_8h.html#a2c80ee5000d4aa103d472eb00c20fd5b">insert_head</a>(list, &amp;p1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> persona));</div>
<div class="line">list = <a class="code" href="list_8h.html#a2c80ee5000d4aa103d472eb00c20fd5b">insert_head</a>(list, &amp;p2, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> persona));</div>
</div><!-- fragment --><p> Let's define the function that compares two struct persona (ex. compare by the age) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> compare_persona(<span class="keywordtype">void</span> *a, <span class="keywordtype">void</span> *b){</div>
<div class="line">  <span class="keyword">struct </span>persona *pa = a;</div>
<div class="line">  <span class="keyword">struct </span>persona *pb = b;</div>
<div class="line">  <span class="keywordflow">return</span> pa-&gt;age - pb-&gt;age;</div>
<div class="line">}</div>
</div><!-- fragment --><p> And if we call the function </p><div class="fragment"><div class="line"><span class="keyword">struct </span>persona max = <a class="code" href="list_8h.html#a951ef51ed47fe41133ba1b2e357bab17">max_list</a>(list, compare_persona); </div>
</div><!-- fragment --><p> The result is: </p><pre class="fragment">* @p max = { "valerio", 29 }
* </pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code></code>(const <code>struct</code> <code>node*</code>) Const pointer to a struct node that rappresent the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>NULL</code> if the list is empty</li>
<li><code>void*</code> if the list isn't empty </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a16fb0960f3c79b071bd205359eb4fa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fb0960f3c79b071bd205359eb4fa4a">&#9670;&nbsp;</a></span>min_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* min_list </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structnode.html">node</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *a, void *b)&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the min of the list. </p>
<p>This function returns the min of the list.The user pass a function pointer to the function that rappresent the criteria that two memory object are compared. <code>Example</code> Let's define this structure </p><div class="fragment"><div class="line"><span class="keyword">struct </span>persona { <span class="keywordtype">char</span> name[20], <span class="keywordtype">int</span> age};</div>
</div><!-- fragment --><p> Then fill the list of struct persona </p><div class="fragment"><div class="line"><span class="keyword">struct </span>persona p1 = { <span class="stringliteral">&quot;omar&quot;</span>, 19 };</div>
<div class="line"><span class="keyword">struct </span>persona p2 = { <span class="stringliteral">&quot;valerio&quot;</span>, 29};</div>
<div class="line"> </div>
<div class="line">list = <a class="code" href="list_8h.html#a2c80ee5000d4aa103d472eb00c20fd5b">insert_head</a>(list, &amp;p1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> persona));</div>
<div class="line">list = <a class="code" href="list_8h.html#a2c80ee5000d4aa103d472eb00c20fd5b">insert_head</a>(list, &amp;p2, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> persona));</div>
</div><!-- fragment --><p> Let's define the function that compares two struct persona (ex. compare by the age) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> compare_persona(<span class="keywordtype">void</span> *a, <span class="keywordtype">void</span> *b){</div>
<div class="line">  <span class="keyword">struct </span>persona *pa = a;</div>
<div class="line">  <span class="keyword">struct </span>persona *pb = b;</div>
<div class="line">  <span class="keywordflow">return</span> pa-&gt;age - pb-&gt;age;</div>
<div class="line">}</div>
</div><!-- fragment --><p> And if we call the function </p><div class="fragment"><div class="line"><span class="keyword">struct </span>persona max = <a class="code" href="list_8h.html#a16fb0960f3c79b071bd205359eb4fa4a">min_list</a>(list, compare_persona); </div>
</div><!-- fragment --><p> The result is: </p><pre class="fragment">* @p max = { "omar", 19 }
* </pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code></code>(const <code>struct</code> <code>node*</code>) Const pointer to a struct node that rappresent the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>NULL</code> if the list is empty</li>
<li><code>void*</code> if the list isn't empty </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astructnode_html"><div class="ttname"><a href="structnode.html">node</a></div><div class="ttdoc">Basic node element.</div><div class="ttdef"><b>Definition:</b> list.h:26</div></div>
<div class="ttc" id="alist_8h_html_a2c80ee5000d4aa103d472eb00c20fd5b"><div class="ttname"><a href="list_8h.html#a2c80ee5000d4aa103d472eb00c20fd5b">insert_head</a></div><div class="ttdeci">struct node * insert_head(struct node *list, const void *data, size_t data_size)</div><div class="ttdoc">Insert a new node at the head.</div></div>
<div class="ttc" id="alist_8h_html_a951ef51ed47fe41133ba1b2e357bab17"><div class="ttname"><a href="list_8h.html#a951ef51ed47fe41133ba1b2e357bab17">max_list</a></div><div class="ttdeci">void * max_list(const struct node *list, int(*compare)(void *a, void *b))</div><div class="ttdoc">Calculate the max of the list.</div></div>
<div class="ttc" id="alist_8h_html_a16fb0960f3c79b071bd205359eb4fa4a"><div class="ttname"><a href="list_8h.html#a16fb0960f3c79b071bd205359eb4fa4a">min_list</a></div><div class="ttdeci">void * min_list(const struct node *list, int(*compare)(void *a, void *b))</div><div class="ttdoc">Calculate the min of the list.</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="list_8h.html">list.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
